/* * BasicSigmaDelta.cpp
 *
 *	Implementation of BasicSigmaDelta algortihm for motion detection. 
 * 
 *  Created on: Jan 18, 2016
 *  Authors: Ivan Pavić, Ivan Spasić 
 */
#include <highgui.hpp>
#include <opencv.hpp>
#include <imgproc.hpp>
#include <iostream>
#include <cmath>
#include <chrono>
#include <UnixIPCHelper.h>
#include <base64.h>
#include <functional>


using namespace std;
using namespace cv;
using namespace std::chrono;

typedef std::function<void(void)> ProfilingWrapper;

void measureTime(ProfilingWrapper wrapper, string description) {
	high_resolution_clock::time_point startTime = high_resolution_clock::now();
	wrapper();
	high_resolution_clock::time_point stopTime = high_resolution_clock::now();
	cout << "Time elapsed for " << description << " is :";
	cout << duration_cast<microseconds>(stopTime - startTime).count() << endl;
}

void callback(char *data) {
	std::cout << data << std::endl;
}

void basicSigmaDeltaBS(Mat &I, Mat &M, Mat &V, Mat &E) {
	uchar *I_p;
	uchar *M_p;
	uchar *V_p;
	uchar *E_p;
	for(int i = 0; i < I.rows; i++) {
		I_p = I.ptr<uchar>(i);
		M_p = M.ptr<uchar>(i);
		V_p = V.ptr<uchar>(i);
		E_p = E.ptr<uchar>(i);
		for(int j = 0; j < I.cols; j++) {
			// if (V_p[j] > 256/pow2) {
			if (M_p[j] < I_p[j]) {
				M_p[j]++;
			} else if (M_p[j] > I_p[j]) {
				M_p[j]--;
			}
			// }
			uchar O = abs(M_p[j] - I_p[j]);
			if (O != 0) {
				if (V_p[j] < 2*O) {
					V_p[j]++;
				} else if (V_p[j] > 2*O) {
					V_p[j]--;
				}
			}
			if (O < V_p[j]) {
				E_p[j] = (uchar)0;
				
			} else if (O > V_p[j]) {
				E_p[j] = (uchar)255;
			}
		}
	}
}

 
int main(int argc, char** argv) {
	cout << "Background estimation using Sigma-Delta algorithm..." << endl;

	if (argc != 2) {
		cout << "Provide camera device id as argument!" << endl;
		return -1;	
	}		

	Mat I, M, V, E, O;
	vector<unsigned char> buff;
	vector<int> params = vector<int>(2);
	params[0] = CV_IMWRITE_JPEG_QUALITY;
	params[1] = 50;
	UnixIPCHelper node(string("/tmp/node_img"), callback);
	node.bindNode();
	node.listenNode();
	VideoCapture cap(atoi(argv[1]));

	if (!cap.isOpened()) {
		cerr << "Err: Initalizing video capture" << endl;
		return -1;
	}

//	namedWindow("Raw",CV_WINDOW_AUTOSIZE); //raw feed
//	namedWindow("M",CV_WINDOW_AUTOSIZE); //background estimator feed
//	namedWindow("V",CV_WINDOW_AUTOSIZE); //variance feed
//	namedWindow("E",CV_WINDOW_AUTOSIZE); //resulting binary feed


	cap.read(I);
	cvtColor(I, I, CV_RGB2GRAY);

	M = Mat_<uchar>(I.rows, I.cols);
	V = Mat_<uchar>(I.rows, I.cols);
	E = Mat_<uchar>(I.rows, I.cols);

	Mat element = getStructuringElement( 0, Size(3, 3), Point (1, 1) );
	
	uchar *I_p;
	uchar *M_p;
	uchar *V_p;
	uchar *E_p;
	
	high_resolution_clock::time_point timeCaptureStart;
	high_resolution_clock::time_point timeCaptureStop;
	high_resolution_clock::time_point timeSigmaDeltaStart;
	high_resolution_clock::time_point timeSigmaDeltaStop;
	high_resolution_clock::time_point timeMorphFilterStart;
	high_resolution_clock::time_point timeMorphFilterStop;
	high_resolution_clock::time_point timeShowStart;
	high_resolution_clock::time_point timeShowStop;
	high_resolution_clock::time_point timeEncodeJPEGStart;
	high_resolution_clock::time_point timeEncodeJPEGStop;
	high_resolution_clock::time_point timeEncodeBase64Start;
	high_resolution_clock::time_point timeEncodeBase64Stop;
	high_resolution_clock::time_point timeSendToNodeStart;
	high_resolution_clock::time_point timeSendToNodeStop;
	high_resolution_clock::time_point timeContourProcessStart;
	high_resolution_clock::time_point timeContourProcessStop;


	int disturbedPixels = 0;
	
	while (1) {
		// if (t > 255) {
		// 	t = 0;
		// }
		
		// t++;
		
		// int rank = (t % 256); 
		// int pow2 = 1;
		// int thres = 256;
		// do {
		// 	pow2 = pow2 * 2;
		// 	thres = thres / 2; 
		// } while((rank % pow2 == 0) && (thres > 1));	
		
		timeCaptureStart = high_resolution_clock::now();
		bool captureSuccess = cap.read(I); /* read a new frame from camera feed */
		
		if (!captureSuccess) {
			cerr << "Err: reading from camera feed" << endl;
			break;
		}
		
		measureTime([&I] () {cvtColor(I, I, CV_RGB2GRAY);}, "conversion to grayscale");
		
		timeCaptureStop = high_resolution_clock::now();
		
		timeSigmaDeltaStart = high_resolution_clock::now();
		
		measureTime([&I, &M, &V, &E] () {basicSigmaDeltaBS(I, M, V, E);}, "sigma delta background subtraction");
		
		// for(int i = 0; i < I.rows; i++) {
		// 		I_p = I.ptr<uchar>(i);
		// 		M_p = M.ptr<uchar>(i);
		// 		V_p = V.ptr<uchar>(i);
		// 		E_p = E.ptr<uchar>(i);
		// 	for(int j = 0; j < I.cols; j++) {
		// 		// if (V_p[j] > 256/pow2) {
		// 		if (M_p[j] < I_p[j]) {
		// 			M_p[j]++;
		// 		} else if (M_p[j] > I_p[j]) {
		// 			M_p[j]--;
		// 		}
		// 		// }
		// 		uchar O = abs(M_p[j] - I_p[j]);
		// 		if (O != 0) {
		// 			if (V_p[j] < 2*O) {
		// 				V_p[j]++;
		// 			} else if (V_p[j] > 2*O) {
		// 				V_p[j]--;
		// 			}
		// 		}
		// 		if (O < V_p[j]) {
		// 			E_p[j] = (uchar)0;
		// 			disturbedPixels++;
		// 		} else if (O > V_p[j]) {
		// 			E_p[j] = (uchar)255;
		// 		}
		// 	}
		// }
		timeSigmaDeltaStop = high_resolution_clock::now();
		timeMorphFilterStart = high_resolution_clock::now();
		measureTime([&E] () {morphologyEx(E, E, 2, element);}, "morphology processing"); 
		timeMorphFilterStop = high_resolution_clock::now();
		
		//crtanje
		
		timeContourProcessStart = high_resolution_clock::now();

		vector<vector<Point>> contours;
		vector<Vec4i> hierarchy;
		
		Mat canny_out;

		int thresh = 10;

		Canny(E, canny_out, thresh, thresh * 2, 3);

		findContours(E, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, Point(0, 0));

		for(unsigned int i = 0; i < contours.size(); i++) {
			uchar color = 0;
			drawContours(I, contours, i, color, 10, 8, hierarchy, 0, Point());		
		//	cout << "Veličina konture je: " << contourArea(contours[i]) << endl;
		}
		
		timeContourProcessStop = high_resolution_clock::now();


		timeShowStart = high_resolution_clock::now();
	//	imshow("Raw", I); /* show raw frame */
	//	imshow("M", M); /* show background estimation frame */
	//	imshow("V", V); /* show variance estimation frame */
	//	imshow("E", E);   /* show motion detection frame */
		timeShowStop = high_resolution_clock::now();
		
		timeEncodeJPEGStart = high_resolution_clock::now();	
		imencode(".jpg", I, buff, params);
		timeEncodeJPEGStop = high_resolution_clock::now();
		
		timeEncodeBase64Start = high_resolution_clock::now();
		string encoded = base64_encode(&buff[0], buff.size());
		timeEncodeBase64Stop = high_resolution_clock::now();
		
		timeSendToNodeStart = high_resolution_clock::now();
		node.sendNode(encoded.c_str());
		timeSendToNodeStop = high_resolution_clock::now();
		
		// cout << "Profiling results: " << endl;
		// cout << "Capture time (ms): ";
		// cout << duration_cast<milliseconds>(timeCaptureStop - timeCaptureStart).count() << endl;
		// cout << "SigmaDelta time (ms): ";
		// cout << duration_cast<milliseconds>(timeSigmaDeltaStop - timeSigmaDeltaStart).count() << endl;
		// cout << "Morphological filter time (ms): ";
		// cout << duration_cast<milliseconds>(timeMorphFilterStop - timeMorphFilterStart).count() << endl;
		// cout << "Imshow time (ms): ";
		// cout << duration_cast<milliseconds>(timeShowStop - timeShowStart).count() << endl;
		// cout << "Encoding JPEG time (us): ";
		// cout << duration_cast<microseconds>(timeEncodeJPEGStop - timeEncodeJPEGStart).count() << endl;
		// cout << "Encoding Base64 time (us): ";
		// cout << duration_cast<microseconds>(timeEncodeBase64Stop - timeEncodeBase64Start).count() << endl;
		// cout << "Sending to socket time (us): ";
		// cout << duration_cast<microseconds>(timeSendToNodeStop - timeSendToNodeStart).count() << endl;
		// cout << "Contour processing time (us): ";
		// cout << duration_cast<microseconds>(timeContourProcessStop - timeContourProcessStart).count() << endl;	
		
		
		
		waitKey(10);
	}
	return 0;
}


